ifeq (${STAGE},)
STAGE = dev
endif

SERVICE_NAME := imds
MAJOR_VERSION := 0
SERVICE_VERSION := 0.0.0
ROOT_NAME := aqfer
DB_STACK_NAME := ${SERVICE_NAME}Cache-${STAGE}
ECS_STACK_NAME := ${SERVICE_NAME}-${STAGE}
ROLE_STACK_NAME := ${SERVICE_NAME}Role-${STAGE}
ECR_REGION := us-east-1
# Update this when adding more regions
AWS_REGIONS := us-east-1 us-west-2 eu-west-1

JWT := testkey

INSTANCE_TYPE := t2.medium
# INSTANCE_TYPE := c5.large
# api-preprod.aqfer.net
# R53_HOSTED_ZONE_NAME:= api-preprod.aqfer.net.
# SERVICE_DOMAIN_CERTIFICATE_ID := 90250d8c-396a-4c19-a488-82e301e283c0
# DNS_SUBDOMAIN := imds
# api.aqfer.net
R53_HOSTED_ZONE_NAME:= api.aqfer.net.
SERVICE_DOMAIN_CERTIFICATE_ID := e858c27f-84c2-4f3d-a27f-be12b453f50e
DNS_SUBDOMAIN := imds-preprod
APP_LOG_GROUP_NAME := ${SERVICE_NAME}
KEYPAIR_NAME := ${ROOT_NAME}_${SERVICE_NAME}-${STAGE}

EC_SECURITY_GROUP := ${SERVICE_NAME}Cache-${STAGE}
EC_CLUSTER_NAME := ${SERVICE_NAME}Cache-${STAGE}
EC_NODE_TYPE := cache.m4.large
EC_SUBNET_GROUP := ${SERVICE_NAME}Cache-${STAGE}
PARTITION_KEY := partition-key
SORT_KEY := sort-key

TASK_DEFINITION := ${SERVICE_NAME}TaskDefinition-${STAGE}
EC2_SECURITY_GROUP := ${SERVICE_NAME}EC2-${STAGE}
EC2_INSTANCE_ROLE_NAME := ${SERVICE_NAME}EC2InstanceRole-${STAGE}
EC2_INSTANCE_PROFILE_NAME := ${SERVICE_NAME}EC2InstanceProfile-${STAGE}
ECS_CLUSTER_NAME := ${SERVICE_NAME}ECS-${STAGE}
ECS_LOG_GROUP_NAME := /ecs/${TASK_DEFINITION}
ECS_TARGET_GROUP_NAME := ${SERVICE_NAME}TargetGroup-${STAGE}
ECS_SERVICE_NAME := ${SERVICE_NAME}Service-${STAGE}
ECS_SERVICE_ROLE_NAME := ${SERVICE_NAME}ServiceRole-${STAGE}
LOAD_BALANCER_NAME := ${SERVICE_NAME}-${STAGE}
LB_SECURITY_GROUP := ${SERVICE_NAME}LB-${STAGE}


# bucket name must be all lowercase, and start/end with lowercase letter or number
ARTIFACTS_BUCKET := cloudformation-${SERVICE_NAME}-art

.PHONY: get_major_version
get_major_version:
	@cat MAJOR_VERSION

.PHONY: get_next_version
get_next_version:
	@cd aqfer/scripts && go get ./... && go run ecr_get_next_version/ecr-get-next-version.go ${ROOT_NAME}_${SERVICE_NAME} $(shell cat MAJOR_VERSION) ${ECR_REGION}

sanity:
	${eval current_version=`build-tool -operation getcurrentversion -projecttype aio -versionurl http://imds-preprod.api.aqfer.net/version`}
	echo current_version is ${current_version}
	if [ ${current_version} = ${VERSION} ]; then echo "sanity test passed"; exit 0; else echo "sanity test failed"; exit 1; fi

.PHONY: setup_and_launch
setup_and_launch: setup launch

# only needed on first run, to make clean aws docker image
# to make cloud-formation artifacts bucket
# and to make and store locally an ec2 keypair
.PHONY: setup
setup: aws_build create_artifact_bucket create_keypair

# this launches the full stack: first the db,
# then update_container_repo writes the db endpoints on the caddyfile and updates the runtime image
# and last, the runtime stack (ECS) goes up with the newly updated docker image
.PHONY: launch
launch: spin_up_db update_container_repo spin_up_ecs

# update ecs to use the latest image
.PHONY: update_ecs
update_ecs: aws_build spin_up_ecs


# has to be run after databases are up or else the caddyfile database sections will point to nothing
# has to be run after databases are up or else the caddyfile database sections will point to nothing
.PHONY: update_container_repo
update_container_repo: ready_caddyfile ecr_repo_push


# deployment environment base image
.PHONY: build_base_image
build_base_image:
	docker build -f aqfer/Dockerfile.base -t base_image .

.PHONY: build_clean_base_image
build_clean_base_image:
	docker build --no-cache -f aqfer/Dockerfile.base -t base_image .

# deployment environment image
.PHONY: aws_build
aws_build: build_base_image
	docker build --no-cache -f aqfer/Dockerfile.aws -t aws_image .


.PHONY: build_new_caddy_image
build_new_caddy_image: build_caddy
	docker build --no-cache -f aqfer/Dockerfile.caddy -t ${ROOT_NAME}_${SERVICE_NAME} .

.PHONY: build_caddy_image
build_caddy_image: build_caddy
	docker build -f aqfer/Dockerfile.caddy -t ${ROOT_NAME}_${SERVICE_NAME} .

.PHONY: build_caddy
build_caddy: get_next_version
	cd caddy && go run build.go --goos linux


.PHONY: create_artifact_bucket
create_artifact_bucket:
	docker run \
	-e AWS_ACCESS_KEY_ID \
	-e AWS_SECRET_ACCESS_KEY \
	-e AWS_DEFAULT_REGION \
	--entrypoint aws aws_image s3 mb s3://${ARTIFACTS_BUCKET}/

.PHONY: create_keypair
create_keypair:
	for region in ${AWS_REGIONS} ; do \
		docker run \
		-e AWS_ACCESS_KEY_ID \
		-e AWS_SECRET_ACCESS_KEY \
		-e Region=$$region \
		--entrypoint /scripts/keypair.sh aws_image ${KEYPAIR_NAME} 2>&1 > aqfer/aws/${KEYPAIR_NAME}_$$region.pem ; \
		chmod 700 aqfer/aws/${KEYPAIR_NAME}_$$region.pem ; \
	done

.PHONY: setup_roles
setup_roles:
	docker run \
	-e AWS_ACCESS_KEY_ID \
	-e AWS_SECRET_ACCESS_KEY \
	-e AWS_DEFAULT_REGION \
	-e EC2InstanceRoleName=${EC2_INSTANCE_ROLE_NAME} \
	-e EC2InstanceProfileName=${EC2_INSTANCE_PROFILE_NAME} \
	-e ECSServiceRoleName=${ECS_SERVICE_ROLE_NAME} \
	-e ECRRepoName=${ROOT_NAME}_${SERVICE_NAME} \
	--entrypoint /scripts/setup_roles.sh aws_image ${ARTIFACTS_BUCKET} ${ROLE_STACK_NAME}

.PHONY: spin_up_db
spin_up_db:
	for region in ${AWS_REGIONS} ; do \
		docker run \
		-e AWS_ACCESS_KEY_ID \
		-e AWS_SECRET_ACCESS_KEY \
		-e AWS_DEFAULT_REGION \
		-e ECSecurityGroupName=${EC_SECURITY_GROUP} \
		-e ECSubnetGroupName=${EC_SUBNET_GROUP} \
		-e ECNodeType=${EC_NODE_TYPE} \
		-e ECClusterName=${EC_CLUSTER_NAME} \
		-e ServiceStage=${STAGE} \
		-e ArtifactBucket=${ARTIFACTS_BUCKET} \
		-e StackRegion=$$region \
		--entrypoint /scripts/spin_up_db.sh aws_image ${ARTIFACTS_BUCKET} ${DB_STACK_NAME} ; \
 	done

.PHONY: tear_down_db
tear_down_db:
	docker run \
	-e AWS_ACCESS_KEY_ID \
	-e AWS_SECRET_ACCESS_KEY \
	-e AWS_DEFAULT_REGION \
	--entrypoint aws aws_image cloudformation delete-stack --stack-name ${DB_STACK_NAME}

.PHONY: ready_caddyfile
ready_caddyfile:
	cat aqfer/Caddyfile_template | sed 's/APP_LOG_GROUP_NAME/'${APP_LOG_GROUP_NAME}'/g' > aqfer/Caddyfile


.PHONY: ecr_repo_push
ecr_repo_push: ready_caddyfile build_caddy_image ecr_push

.PHONY: ecr_push
ecr_push:
	cd aqfer/scripts && go get ./... && go run push_docker_image/push-docker-image.go ${ROOT_NAME}_${SERVICE_NAME} ${VERSION} ${ECR_REGION}


.PHONY: spin_up_ecs
spin_up_ecs:
	for region in ${AWS_REGIONS} ; do \
		docker run -e AWS_ACCESS_KEY_ID -e AWS_SECRET_ACCESS_KEY -e AWS_DEFAULT_REGION \
		-e Jwt=${JWT} \
		-e KeyPair=${KEYPAIR_NAME} \
		-e LoadBalancerName=${LOAD_BALANCER_NAME} \
		-e LBSecurityGroupName=${LB_SECURITY_GROUP} \
		-e TargetGroupName=${ECS_TARGET_GROUP_NAME} \
		-e EC2InstanceType=${INSTANCE_TYPE} \
		-e EC2SecurityGroupName=${EC2_SECURITY_GROUP} \
		-e EC2InstanceRoleName=${EC2_INSTANCE_ROLE_NAME} \
		-e EC2InstanceProfileName=${EC2_INSTANCE_PROFILE_NAME} \
		-e ECSClusterName=${ECS_CLUSTER_NAME} \
		-e ECSServiceRoleName=${ECS_SERVICE_ROLE_NAME} \
		-e ECSTaskDefinitionName=${TASK_DEFINITION} \
		-e ECSServiceName=${ECS_SERVICE_NAME} \
		-e ECRRepoURI=$(shell cat aqfer/aws/ecrUri):${VERSION} \
		-e ECRRepoName=${ROOT_NAME}_${SERVICE_NAME} \
		-e ECRRepoRegion=${ECR_REGION} \
		-e ImageVersion=${VERSION} \
		-e ContainerName=${ROOT_NAME}-${SERVICE_NAME} \
		-e AppLogGroupName=${APP_LOG_GROUP_NAME} \
		-e ECSLogGroupName=${ECS_LOG_GROUP_NAME} \
		-e DomainCertificateId=${SERVICE_DOMAIN_CERTIFICATE_ID} \
		-e ServiceStage=${STAGE} \
		-e ECStackName=${DB_STACK_NAME} \
		-e ArtifactBucket=${ARTIFACTS_BUCKET} \
		-e StackRegion=$$region \
		--entrypoint /scripts/spin_up_ecs.sh aws_image ${ARTIFACTS_BUCKET} ${ECS_STACK_NAME} \
		${EC_SECURITY_GROUP} ; \
	done

# make instances=i-029aefe585538720b\ i-09abb841e51433e42 tear_down_ecs
# must list specific ec2 instances to destroy (delimited by spaces)
.PHONY: tear_down_ecs
tear_down_ecs:
ifdef instances
	docker run \
	-e AWS_ACCESS_KEY_ID \
	-e AWS_SECRET_ACCESS_KEY \
	-e AWS_DEFAULT_REGION \
	--entrypoint aws aws_image ec2 revoke-security-group-ingress --group-name ${EC_SECURITY_GROUP} --source-group ${EC2_SECURITY_GROUP} --port \
	ec2 terminate-instances --instance-ids $(instances);\
	aws ec2 wait instance-terminated --instance-ids $(instances);\
	aws cloudformation delete-stack --stack-name ${ECS_STACK_NAME}
else
	@echo "\ninstances to destroy were not declared, cloudformation stack delete will not execute for ecs.\nRun `make instances=... tear_down_ecs`"
endif


# `make instances=i-029aefe585538720b\ i-09abb841e51433e42 tear_down_stacks`
# must list specific ec2 instances to destroy (delimited by spaces)
# this command will not destroy the EC2 KeyPair that was created
.PHONY: tear_down_stacks
tear_down_stacks: tear_down_db tear_down_ecs


# run `make get_dns_name` to get service address
.PHONY: get_dns_name
get_dns_name:
	docker run \
	-e AWS_ACCESS_KEY_ID \
	-e AWS_SECRET_ACCESS_KEY \
	-e AWS_DEFAULT_REGION \
	--entrypoint aws aws_image elbv2 describe-load-balancers --names ${LOAD_BALANCER_NAME} 2>&1 > /tmp/DNSName
	@echo $(shell cat /tmp/DNSName | sed -n -E "s/.*\"DNSName\".*\"(.*)\",/\1/p")


.PHONY: stop_tasks
stop_tasks:
	docker run \
	-e AWS_ACCESS_KEY_ID \
	-e AWS_SECRET_ACCESS_KEY \
	-e AWS_DEFAULT_REGION \
	--entrypoint /scripts/stop_tasks.sh aws_image ${ECS_CLUSTER_NAME}


.PHONY: run_locally
run_locally:
	docker run \
	-e AWS_ACCESS_KEY_ID \
	-e AWS_SECRET_ACCESS_KEY \
	-e AWS_DEFAULT_REGION \
	--expose 8082 -p 8082:8082 \
	--entrypoint ./caddy aqfer_imds

.PHONY: startover_locally
startover_locally: build_caddy_image run_locally


.PHONY: run_unit_tests
run_unit_tests:
	docker run \
	-e AWS_ACCESS_KEY_ID \
	-e AWS_SECRET_ACCESS_KEY \
	-e AWS_DEFAULT_REGION \
	--expose 8082 -p 8082:8082 \
	--entrypoint /run_unit_tests.sh aqfer_imds
